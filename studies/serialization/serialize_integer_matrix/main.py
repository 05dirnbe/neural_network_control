import flatbuffers
# Generated by `flatc`.
import Buffer.IntegerArray
import Buffer.IntegerMatrix

import numpy as np

builder = flatbuffers.Builder(0)

n= 2
m = 3
np.random.seed(0)
matrix = np.random.random_integers(0, 1, (n, m))

print matrix

flat_matrix = matrix.flatten()

# Serialize the FlatBuffer data.
# Note: Since we prepend the items, this loop iterates in reverse order.

Buffer.IntegerMatrix.IntegerMatrixStartDataVector(builder, len(flat_matrix))
for value in reversed(flat_matrix):
	builder.PrependUint32(value)
data = builder.EndVector(len(flat_matrix))

Buffer.IntegerMatrix.IntegerMatrixStart(builder)

Buffer.IntegerMatrix.IntegerMatrixAddN(builder, n)
Buffer.IntegerMatrix.IntegerMatrixAddM(builder, m)
Buffer.IntegerMatrix.IntegerMatrixAddData(builder, data)
l = Buffer.IntegerMatrix.IntegerMatrixEnd(builder)

builder.Finish(l)

# We now have a FlatBuffer that we could store on disk or send over a network.

# ...Saving to file or sending over a network code goes here...

# Instead, we are going to access this buffer right away (as if we just
# received it).

buf = builder.Output()

# Note: We use `0` for the offset here, since we got the data using the
# `builder.Output()` method. This simulates the data you would store/receive
# in your FlatBuffer. If you wanted to read from the `builder.Bytes` directly,
# you would need to pass in the offset of `builder.Head()`, as the builder
# actually constructs the buffer backwards.
container = Buffer.IntegerMatrix.IntegerMatrix.GetRootAsIntegerMatrix(buf, 0)
# Get and test the `values` FlatBuffer `vector`.

flat_matrix = np.array([ container.Data(i) for i in xrange(container.DataLength()) ])
matrix = flat_matrix.reshape(container.N(),container.M())

print matrix
