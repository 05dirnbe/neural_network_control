import flatbuffers
# Generated by `flatc`.
import Buffer.Spike
import Buffer.SpikesArray

n = 3
spikes = []


builder = flatbuffers.Builder(0)

# first we build the spikes themselves
for i in range(n):

	Buffer.Spike.SpikeStart(builder)
	Buffer.Spike.SpikeAddTimestamp(builder,i)
	Buffer.Spike.SpikeAddAddress(builder,i*10)
	spike = Buffer.Spike.SpikeEnd(builder)
	spikes.append(spike)

# next we build a vector that holds the spikes
Buffer.SpikesArray.SpikesArrayStartListVector(builder, n)

for s in reversed(spikes):
	builder.PrependUOffsetTRelative(s)

data = builder.EndVector(n)

# then we add the vector to the buffer
Buffer.SpikesArray.SpikesArrayStart(builder)
Buffer.SpikesArray.SpikesArrayAddList(builder, data)
l = Buffer.SpikesArray.SpikesArrayEnd(builder)

builder.Finish(l)

# We now have a FlatBuffer that we could store on disk or send over a network.

# ...Saving to file or sending over a network code goes here...

# Instead, we are going to access this buffer right away (as if we just
# received it).

buf = builder.Output()

# Note: We use `0` for the offset here, since we got the data using the
# `builder.Output()` method. This simulates the data you would store/receive
# in your FlatBuffer. If you wanted to read from the `builder.Bytes` directly,
# you would need to pass in the offset of `builder.Head()`, as the builder
# actually constructs the buffer backwards.
l = Buffer.SpikesArray.SpikesArray.GetRootAsSpikesArray(buf, 0)
# Get and test the `values` FlatBuffer `vector`

for i in xrange(l.ListLength()):
	# print l.Values(i)
	spike = l.List(i)
	print (spike.Timestamp(), spike.Address())

print 'The FlatBuffer was successfully created and verified!'